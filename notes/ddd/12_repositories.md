# Repositories

## Collection-Oriented
Adheres to the basic ideas presented in the original DDD pattern. Design interface that does not hint there is an underlying persistence mechanism. Must conserve idempotency.

#### The persistence mechanism must in some way support the ability to implicitly track changes made to each persistent object that it manages.

1. Implicit copy-on-read
The persistence mechanism implicitly copies each persistent object on read when it is reconstituted from the data store and compares its private copy to the client's copy on commit

2. Implicit copy-on-write
The persistence mechanism manages all loaded persistent objects through a proxy. As each object is loaded from the data store, a thin proxy is created and handed to the clienT

> explicit means that the client must inform the Unit of Work that changes are about to take place

## Persistence-Oriented
Save-based repository. the persistence mechanism doesn't implicitly or explicitly detect and track object changes

### Coherence Implementation
It differs only in the way it allows Aggregate instances to be included in the mimicked collection.
> save, saveAll other than add, addAll

### MongoDB Implementation
1. A means to seralize Aggregate instances to the MongoDB format, and then deserialize from that format and reconstitute the Aggregate instance.
2. A unique identity generated by MongoDB and assigned to the Aggregate
3. A reference to the MongoDB node/cluster
4. A unique collection in which to store each Aggregate type. All instances of each Aggregate type must be stored as a set of seralized documents in their own collection

## Additional Behaviors

Calculations that must be performed in the data store to meet some stringent nonfunctional requirement. Case if moving the data from its store to where the business logic executes is too slow. Such implementations are often best placed under the control of Domain Services.

System may not follow the eact contours of a single Aggreagte type when rendering views of domain data. In such case, choose not to, in a single transaction, find whole Aggregate instances of various types and then programmatically compose them into a single container, and supply that payload container to a client. Use _a use case optimal query_ instead. This is to specify query against the persistence mechanism, dynamically placing the results into a Value Object.

## Managing Transactions
Manage transactions in the Application Layer. Generally Facade, which business method is invoked by the User Interface Layer.
To enlist changes to the domain model in a transction, ensure that Repository implementations have access to the same Session or Unit of Work for the transaction that the Application Layer started.

## Type Hierarchies
Design to form a hierarchy of closedly related types that have interchangeable, polymorphic characteristics. These kinds of hierarchies use a single Repository to store and retrieve instances of the separate types.

In case where only two or a few such concrete subclasses are necessary, it may be best to create separate Repositories. When the number of concrete subclasses grows to several or many, most of which can be used completely interchangeably (LSP), it is worthwhile for them to share a common Repository.

Standard Type could be designed as a __State__.

The situation could also be sidestepped with the use of role-baed interfaces. Even if inheritance is used, Aggregate polymorphic behavior can most often be carefully designed usch that no special cases are surfaced to clients.

## Repository versus Data Access Object
Design your Repositories with a collection orientation rather than a data access orientation. This will keep you focused on the domain as a model rather than on data and any CRUD operations that may be used behind the scenes to manage its persistence.

## Testing Repositories
__To prove that they work correctly__: must use the full production-quality implementations. Otherwise you won't know if your production code will work.

__To store the Aggregates that they create and to find preexisting ones__: in-memory implementations

