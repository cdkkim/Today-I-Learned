# Introducing Kubernetes


## 1.1. Monolithic application에서 micro service의 전환
각 마이크로서비스는 독립적인 프로세스로 실행되며 단순하고 잘 정의된 인터페이스 API를 통해 다른 마이크로서비스와 통신한다.  마이크로서비스는 일반적으로 RESTful API를 제공하기 위해 HTTP와 같은 동기 프로토콜을 이용해 통신하거나 AMQP와 같은 비동기 프로토콜을 이용해 통신한다.

## 1.2. 컨테이너 기술 소개
가상머신에서 실행하는 프로세스는 별도의 운영체제에서 컨테이너에서 실행된다. 그와 달리 프로세스는 다른 모든 프로세스와 마찬가지로 호스트의 운영체제 내부에서 실행된다.
가상머신 내부에서 실행되는 애플리케이션은 가상머신에서 게스트 OS의 커널에 시스템을 호출하고 커널은 하이퍼바이저를 통해 호스트의 물리적 CPU에서 x86 명령어를 실행한다. 반면 컨테이너는 모두 호스트 OS에서 동작하는 정확히 동일한 커널에서 시스템을 호출한다. 이 단일 커널은 호스트의 CPU에서 x86 명령어를 수행하는 유일한 커널이다.

Image: 애플리케이션과 환경을 패키지로 묶는다. 여기에는 애플리케이션에서 사용할 수 있는 파일 시스템과 이미지가 실행될 때 실행해야 하는 실행 파일의 경로 등과 같은 메타 데이터가 들어있다.
Registry: 도커 이미지를 저장하고 이미지를 쉽게 공유할 수 있는 저장소다.
Container: 실행중인 컨테이너는 도커를 실행하는 호스트에서 실행되는 프로세스지만 호스트와 호스트에서 실행되는 모든 프로세스 간에 완전히 분리돼 있다.

### 컨테이너 격리를 가능하게 하는 메커니즘 소개
컨테이너 격리를 가능하게 하는 메커니즘에는 두 가지가 있다.
1. 각 프로세스가 파일, 프로세스, 네트워크 인터페이스, 호스트 이름 등 시스템에 독립 뷰를 제공하는 리눅스 네임스페이스
2. 프로세스가 소비할 수 있는 리소스의 양(CPU, memory, network 대역폭 등)을 제한할 수 있는 리눅스 컨트롤 그룹(cgroups)이다.

기본적으로 리눅스 시스템은 초기 구동 시 하나의 단일 네임스페이스를 갖는다.

## 1.3. 쿠버네이스 소개
시스템은 마스터 노드와 여러개의 워커 노드로 구성된다. 개발자가 애플리케이션 매니페스트를 마스터에 제출하면 쿠버네티스는 이를 워커 노드 클러스터에 배포한다.

### Kubernetes Cluster Architecture
쿠버네티스 클러스터는 하드웨어 수준에서 많은 노드로 구성되며 두 가지 유형으로 나눌 수 있다.
- 마스터 노드는 쿠버네티스 시스템을 관리하고 통제하는 쿠버네티스 컨트롤 플레인을 관장한다.
- 워커 노드는 실제 배포하고자 하는 애플리케이션의 실행을 담당한다.

#### Control Plane
컨트롤 플레인에서는 클러스터를 관리하고 클러스터의 기능을 실행한다. 구성요소는 다음과 같다.
- 사용자, 컨트롤 플레인과 통신하는 쿠버네티스 API 서버다.
- 애플리케이션을 예약하는 스케줄러
- 구성 요소 복제, 워커 노드 추적, 노드 장애 처리 등 클러스터 수준 기능을 실행하는 컨트롤러 매니저
- etcd는 클러스터 구성을 지속적으로 저장하는 안정적인 분산 데이터 스토리지다.

#### Node
- 컨테이너를 실행하는 도커, rkt 또는 컨테이너 런타임
- API 서버와 통신하고 노드에서 컨테이너를 관리하는 Kubelet
- 애플리케이션 구성 요소 간에 네트워크 트래픽을 분산하는 쿠버네티스 서비스 프록시(kube-proxy)
